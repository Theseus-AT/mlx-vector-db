#!/usr/bin/env python3
"""
Performance Demo f√ºr MLX Vector Database - MLX 0.25.2 Compatible
Zeigt die Performance-Verbesserungen durch MLX 0.25.2, Caching und optimierte Operationen
"""
import requests
import time
import numpy as np
import json
import os

BASE_URL = "http://localhost:8000"

def wait_for_server():
    """Wait for server to be ready"""
    print("üîç Checking server availability...")
    for i in range(30):
        try:
            response = requests.get(f"{BASE_URL}/health", timeout=1)
            if response.status_code == 200:
                print("‚úÖ Server is ready!")
                return
        except:
            pass
        time.sleep(1)
    raise Exception("‚ùå Server not available after 30 seconds")

def get_api_key():
    """Get API key from user or environment"""
    api_key = os.getenv("VECTOR_DB_API_KEY")
    if not api_key:
        api_key = input("Enter your API key (from .env file): ").strip()
        if not api_key:
            print("‚ö†Ô∏è No API key provided, trying without authentication...")
            return None
    return api_key

def create_test_store(api_key: str):
    """Create a test store for performance testing"""
    user_id = "perf_test_user_mlx"
    model_id = "perf_test_model_mlx"
    
    headers = {"Content-Type": "application/json"}
    if api_key:
        headers["X-API-Key"] = api_key
    
    # Delete if exists
    try:
        delete_payload = {"user_id": user_id, "model_id": model_id}
        requests.delete(f"{BASE_URL}/admin/store", json=delete_payload, headers=headers)
    except:
        pass
    
    # Create store
    create_payload = {"user_id": user_id, "model_id": model_id}
    response = requests.post(f"{BASE_URL}/admin/create_store", json=create_payload, headers=headers)
    
    if response.status_code != 200:
        raise Exception(f"Failed to create store: {response.text}")
    
    print(f"‚úÖ Created test store: {user_id}/{model_id}")
    return user_id, model_id

def check_mlx_version():
    """Check MLX version compatibility"""
    try:
        import mlx.core as mx
        version = getattr(mx, '__version__', 'unknown')
        print(f"üß† MLX Version: {version}")
        
        # Test basic MLX operation
        test_array = mx.array([1, 2, 3, 4])
        mx.eval(test_array)
        print(f"‚úÖ MLX operations working")
        
        return version
    except ImportError:
        print("‚ùå MLX not available")
        return None
    except Exception as e:
        print(f"‚ö†Ô∏è MLX test failed: {e}")
        return None

def run_performance_demo():
    """Run comprehensive performance demonstration with MLX 0.25.2"""
    print("üöÄ MLX Vector Database Performance Demo")
    print("üî• MLX 0.25.2 Apple Silicon Optimized")
    print("=" * 60)
    
    # Check MLX availability
    mlx_version = check_mlx_version()
    if not mlx_version:
        print("‚ùå MLX not available. Please install MLX 0.25.2+")
        return
    
    wait_for_server()
    api_key = get_api_key()
    
    headers = {"Content-Type": "application/json"}
    if api_key:
        headers["X-API-Key"] = api_key
    
    # Step 1: Performance Health Check
    print("\n1Ô∏è‚É£ Performance Health Check (MLX 0.25.2)")
    try:
        response = requests.get(f"{BASE_URL}/performance/health", headers=headers)
        if response.status_code == 200:
            health = response.json()
            print(f"   Status: {health['status']}")
            print(f"   MLX Version: {health.get('mlx_version', 'unknown')}")
            print(f"   MLX Operations: {health['mlx_operations']}")
            print(f"   Cache: {health['cache_status']}")
            print(f"   Apple Silicon: {health.get('framework_features', {}).get('apple_silicon_optimized', 'unknown')}")
            print(f"   Unified Memory: {health.get('framework_features', {}).get('unified_memory', 'unknown')}")
        else:
            print(f"   ‚ùå Health check failed: {response.text}")
            return
    except Exception as e:
        print(f"   ‚ùå Health check error: {e}")
        return
    
    # Step 2: Warmup Compiled Functions (MLX 0.25.2)
    print("\n2Ô∏è‚É£ Warming up MLX 0.25.2 compiled functions...")
    try:
        response = requests.post(f"{BASE_URL}/performance/warmup?dimension=384", headers=headers)
        if response.status_code == 200:
            warmup = response.json()
            print(f"   ‚úÖ Warmup completed in {warmup['warmup_time_seconds']:.3f}s")
            print(f"   üìä Operations tested: {', '.join(warmup.get('operations_tested', []))}")
            print(f"   üß† MLX Version: {warmup.get('mlx_version', 'unknown')}")
        else:
            print(f"   ‚ö†Ô∏è Warmup failed: {response.text}")
    except Exception as e:
        print(f"   ‚ö†Ô∏è Warmup error: {e}")
    
    # Step 3: Create Test Store
    print("\n3Ô∏è‚É£ Setting up test environment...")
    try:
        user_id, model_id = create_test_store(api_key)
    except Exception as e:
        print(f"   ‚ùå Failed to create test store: {e}")
        return
    
    # Step 4: Add Test Vectors (with MLX optimization)
    print("\n4Ô∏è‚É£ Adding test vectors with MLX 0.25.2 optimization...")
    vector_count = 5000
    dimension = 384
    
    try:
        # Generate test data - mention MLX optimization
        print(f"   üìä Generating {vector_count} vectors (dim={dimension}) with MLX...")
        start_gen = time.time()
        
        vectors = np.random.rand(vector_count, dimension).astype(np.float32)
        metadata = [{"id": f"test_vec_{i}", "category": f"cat_{i%10}", "mlx_generated": True} for i in range(vector_count)]
        
        gen_time = time.time() - start_gen
        print(f"   ‚ö° Data generation: {gen_time:.3f}s")
        
        add_payload = {
            "user_id": user_id,
            "model_id": model_id,
            "vectors": vectors.tolist(),
            "metadata": metadata
        }
        
        start_time = time.time()
        response = requests.post(f"{BASE_URL}/admin/add_test_vectors", json=add_payload, headers=headers)
        add_time = time.time() - start_time
        
        if response.status_code == 200:
            print(f"   ‚úÖ Added {vector_count} vectors in {add_time:.3f}s")
            print(f"   üìä Rate: {vector_count/add_time:.1f} vectors/second")
            print(f"   üíæ Storage: MLX-optimized NPZ format")
        else:
            print(f"   ‚ùå Failed to add vectors: {response.text}")
            return
            
    except Exception as e:
        print(f"   ‚ùå Vector addition failed: {e}")
        return
    
    # Step 5: Run MLX 0.25.2 Performance Benchmark
    print("\n5Ô∏è‚É£ Running MLX 0.25.2 performance benchmark...")
    benchmark_payload = {
        "user_id": user_id,
        "model_id": model_id,
        "test_size": 1000,  # Additional test vectors
        "query_count": 100,
        "vector_dim": dimension
    }
    
    try:
        print("   üîÑ Running comprehensive benchmark suite...")
        response = requests.post(f"{BASE_URL}/performance/benchmark", json=benchmark_payload, headers=headers)
        
        if response.status_code == 200:
            results = response.json()
            
            # Display results with MLX 0.25.2 emphasis
            print("\nüìä MLX 0.25.2 BENCHMARK RESULTS:")
            print("=" * 50)
            
            # Data Generation Performance
            if "data_generation" in results:
                data_gen = results["data_generation"]
                print(f"üß† MLX Data Generation:")
                print(f"   Framework: {data_gen.get('framework', 'unknown')}")
                print(f"   Time: {data_gen['time_seconds']:.4f}s")
                print(f"   Vectors: {data_gen['vectors_generated']}")
            
            # Vector Addition Performance
            vector_add = results["vector_addition"]
            print(f"\n‚ûï Vector Addition Performance:")
            print(f"   Time: {vector_add['time_seconds']:.3f}s")
            print(f"   Rate: {vector_add['vectors_per_second']:.1f} vectors/sec")
            print(f"   Storage: {vector_add.get('storage_format', 'standard')}")
            
            # Single Query Performance
            single_query = results["single_query"]
            print(f"\nüîç Single Query Performance:")
            print(f"   Basic: {single_query['basic_time']:.4f}s")
            print(f"   MLX Optimized: {single_query['optimized_time']:.4f}s")
            print(f"   üöÄ Speedup: {single_query['speedup_factor']:.1f}x")
            print(f"   üìà Capacity: {single_query['queries_per_second_optimized']:.1f} QPS")
            print(f"   MLX Acceleration: {single_query.get('mlx_acceleration', 'unknown')}")
            
            # Batch Query Performance
            batch_query = results["batch_query"]
            print(f"\nüîÑ Batch Query Performance:")
            print(f"   Batch size: {batch_query['batch_size']} queries")
            print(f"   Total time: {batch_query['total_time']:.4f}s")
            print(f"   üìà Throughput: {batch_query['queries_per_second']:.1f} QPS")
            print(f"   Optimization: {batch_query.get('optimization', 'standard')}")
            
            # MLX Framework Performance
            if "mlx_framework" in results:
                mlx_perf = results["mlx_framework"]
                print(f"\nüß† MLX Framework Performance:")
                print(f"   Computation time: {mlx_perf['computation_time']:.4f}s")
                print(f"   Operations: {', '.join(mlx_perf['operations'])}")
                print(f"   Vectors processed: {mlx_perf['vectors_processed']}")
                print(f"   Framework version: {mlx_perf['framework_version']}")
                print(f"   Unified memory: {mlx_perf['unified_memory']}")
                print(f"   Lazy evaluation: {mlx_perf['lazy_evaluation']}")
            
            # Cache Performance
            cache_perf = results["cache_performance"]
            print(f"\nüíæ Cache Performance:")
            print(f"   Hit rate: {cache_perf['hit_rate_percent']:.1f}%")
            print(f"   Memory usage: {cache_perf['memory_usage_gb']:.2f} GB")
            print(f"   Backend: {cache_perf.get('backend', 'standard')}")
            
            # Overall Summary
            summary = results["summary"]
            estimated_capacity = summary["performance_improvement"]["estimated_capacity"]
            mlx_version = summary.get("mlx_version", "unknown")
            
            print(f"\nüéØ MLX 0.25.2 PERFORMANCE SUMMARY:")
            print("=" * 40)
            print(f"   üß† MLX Version: {mlx_version}")
            print(f"   üöÄ Overall speedup: {summary['performance_improvement']['query_speedup']:.1f}x")
            print(f"   üìà Estimated capacity: {estimated_capacity}")
            print(f"   üíæ Vector database size: {vector_count + benchmark_payload['test_size']} vectors")
            print(f"   üçé Apple Silicon optimized: {summary['performance_improvement'].get('framework_acceleration', 'unknown')}")
            
            # Active Optimizations
            optimizations = summary["optimizations_active"]
            print(f"\n‚úÖ Active Optimizations:")
            for opt_name, enabled in optimizations.items():
                status = "‚úÖ" if enabled else "‚ùå"
                readable_name = opt_name.replace('_', ' ').title()
                print(f"   {status} {readable_name}")
            
            # Performance Rating (MLX 0.25.2 focused)
            speedup = summary["performance_improvement"]["query_speedup"]
            if speedup > 100:
                rating = "üî•üî• OUTSTANDING (MLX 0.25.2 Optimized)"
            elif speedup > 50:
                rating = "üî• EXCELLENT (Apple Silicon Accelerated)"
            elif speedup > 10:
                rating = "‚≠ê VERY GOOD (MLX Optimized)"
            elif speedup > 5:
                rating = "‚úÖ GOOD (Baseline MLX)"
            else:
                rating = "‚ö†Ô∏è NEEDS MLX OPTIMIZATION"
            
            print(f"   üèÜ Performance Rating: {rating}")
            
        else:
            print(f"   ‚ùå Benchmark failed: {response.text}")
            return
            
    except Exception as e:
        print(f"   ‚ùå Benchmark error: {e}")
        return
    
    # Step 6: MLX 0.25.2 Store Optimization
    print("\n6Ô∏è‚É£ MLX 0.25.2 store optimization...")
    try:
        optimize_params = {
            "user_id": user_id, 
            "model_id": model_id, 
            "force_rebuild_index": "true"
        }
        response = requests.post(f"{BASE_URL}/performance/optimize", params=optimize_params, headers=headers)
        
        if response.status_code == 200:
            opt_results = response.json()
            opt_data = opt_results["optimization_results"]
            total_time = opt_results.get("total_time_seconds", 0)
            mlx_version = opt_results.get("mlx_version", "unknown")
            
            print(f"   üß† MLX Version: {mlx_version}")
            print(f"   ‚è±Ô∏è Total optimization time: {total_time:.3f}s")
            
            # Data Loading Optimization
            if "data_loading" in opt_data:
                data_info = opt_data["data_loading"]
                print(f"   üìä Data Loading: {data_info['time_seconds']:.3f}s")
                print(f"       MLX Accelerated: {data_info.get('mlx_accelerated', False)}")
                print(f"       Vectors: {data_info['vector_count']}")
            
            # Index Optimization
            if "index_optimization" in opt_data:
                index_info = opt_data["index_optimization"]
                print(f"   üîó Index Optimization: {index_info['time_seconds']:.3f}s")
                print(f"       Algorithm: {index_info.get('algorithm', 'standard')}")
                print(f"       Nodes: {index_info['index_nodes']}")
                print(f"       Force rebuild: {index_info.get('force_rebuild', False)}")
            
            # Cache Optimization
            if "cache_optimization" in opt_data:
                cache_info = opt_data["cache_optimization"]
                print(f"   üíæ Cache Optimization: {cache_info['time_seconds']:.3f}s")
                print(f"       MLX Kernels cached: {cache_info.get('mlx_kernels_cached', False)}")
            
            # MLX Framework Info
            if "mlx_framework" in opt_data:
                mlx_info = opt_data["mlx_framework"]
                print(f"   üß† MLX Framework Features:")
                print(f"       Version: {mlx_info['version']}")
                print(f"       Unified Memory: {mlx_info['unified_memory']}")
                print(f"       Metal Kernels: {mlx_info['metal_kernels']}")
                print(f"       Lazy Evaluation: {mlx_info['lazy_evaluation']}")
            
            print(f"   ‚úÖ MLX 0.25.2 optimization completed")
        else:
            print(f"   ‚ö†Ô∏è Optimization failed: {response.text}")
            
    except Exception as e:
        print(f"   ‚ö†Ô∏è Optimization error: {e}")
    
    # Step 7: Final Performance Stats
    print("\n7Ô∏è‚É£ Final MLX 0.25.2 performance statistics...")
    try:
        response = requests.get(f"{BASE_URL}/performance/stats", headers=headers)
        
        if response.status_code == 200:
            stats = response.json()
            mlx_version = stats.get("mlx_framework", "unknown")
            
            print(f"üß† MLX Framework: {mlx_version}")
            
            # System Info
            system_info = stats.get("system_info", {})
            print(f"System Information:")
            print(f"   MLX Available: {system_info.get('mlx_available', 'unknown')}")
            print(f"   MLX Version: {system_info.get('mlx_version', 'unknown')}")
            print(f"   Devices: {', '.join(system_info.get('devices', []))}")
            print(f"   Unified Memory: {system_info.get('unified_memory', 'unknown')}")
            
            # Performance Stats
            performance = stats.get("performance", {})
            if performance:
                print(f"Performance Features:")
                compiled_funcs = performance.get("compiled_functions", {})
                if compiled_funcs:
                    print(f"   Compiled Functions: {compiled_funcs.get('status', 'unknown')}")
                    print(f"   JIT Enabled: {compiled_funcs.get('jit_enabled', 'unknown')}")
                
                cache_info = performance.get("cache", {})
                if cache_info:
                    print(f"   Cache Status: {cache_info.get('status', 'unknown')}")
                
                optimization = performance.get("optimization", {})
                if optimization:
                    print(f"   Lazy Evaluation: {optimization.get('lazy_evaluation', 'unknown')}")
                    print(f"   Metal Kernels: {optimization.get('metal_kernels', 'unknown')}")
                    print(f"   Apple Silicon Optimized: {optimization.get('apple_silicon_optimized', 'unknown')}")
        else:
            print(f"   ‚ö†Ô∏è Stats failed: {response.text}")
            
    except Exception as e:
        print(f"   ‚ö†Ô∏è Stats error: {e}")
    
    print(f"\nüéâ MLX 0.25.2 Performance Demo Completed!")
    print("\nüí° Key MLX 0.25.2 Takeaways:")
    print("   üß† Apple MLX Framework: Optimized for Apple Silicon")
    print("   ‚ö° Unified Memory Model: Zero-copy operations between CPU/GPU")
    print("   üîÑ Lazy Evaluation: Arrays computed only when needed")
    print("   üöÄ Metal Kernels: GPU acceleration with caching")
    print("   üìà Combined Performance: 10-100x speedup potential")
    print("   üçé Native ARM64: Maximum hardware utilization")
    
    # Advanced MLX Features
    print("\nüî¨ Advanced MLX 0.25.2 Features:")
    print("   üéØ Composable Function Transformations")
    print("   üîß Dynamic Graph Construction")
    print("   üõ°Ô∏è Type Safety with NumPy Compatibility")
    print("   ‚öôÔ∏è JIT Compilation with Metal Kernels")
    
    # Cleanup
    print(f"\nüßπ Cleaning up test store...")
    try:
        delete_payload = {"user_id": user_id, "model_id": model_id}
        requests.delete(f"{BASE_URL}/admin/store", json=delete_payload, headers=headers)
        print(f"   ‚úÖ Test store deleted")
    except Exception as e:
        print(f"   ‚ö†Ô∏è Cleanup warning: {e}")

def print_mlx_system_info():
    """Print detailed MLX system information"""
    print("\nüîç MLX 0.25.2 System Information:")
    print("-" * 40)
    
    try:
        import mlx.core as mx
        import platform
        
        print(f"MLX Version: {getattr(mx, '__version__', 'unknown')}")
        print(f"Platform: {platform.platform()}")
        print(f"Processor: {platform.processor()}")
        print(f"Python: {platform.python_version()}")
        
        # Test MLX capabilities
        test_array = mx.array([1.0, 2.0, 3.0])
        mx.eval(test_array)
        print(f"MLX Operations: ‚úÖ Working")
        
        # Test device capabilities
        try:
            # Test random number generation
            random_test = mx.random.normal((10, 10))
            mx.eval(random_test)
            print(f"Random Generation: ‚úÖ Working")
        except:
            print(f"Random Generation: ‚ùå Issues")
        
        try:
            # Test matrix operations
            a = mx.array([[1.0, 2.0], [3.0, 4.0]])
            b = mx.array([[5.0, 6.0], [7.0, 8.0]])
            c = mx.matmul(a, b)
            mx.eval(c)
            print(f"Matrix Operations: ‚úÖ Working")
        except:
            print(f"Matrix Operations: ‚ùå Issues")
            
    except ImportError:
        print("‚ùå MLX not installed")
        print("Install with: pip install mlx>=0.25.2")
    except Exception as e:
        print(f"‚ùå MLX test failed: {e}")

if __name__ == "__main__":
    try:
        print_mlx_system_info()
        run_performance_demo()
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è Demo interrupted by user")
    except Exception as e:
        print(f"\n‚ùå Demo failed: {e}")
        import traceback
        traceback.print_exc()
        print("\nüîß Troubleshooting:")
        print("   1. Ensure MLX 0.25.2+ is installed: pip install mlx>=0.25.2")
        print("   2. Check server is running: python main.py")
        print("   3. Verify API key in .env file")
        print("   4. Test MLX directly: python -c 'import mlx.core as mx; print(mx.__version__)'")